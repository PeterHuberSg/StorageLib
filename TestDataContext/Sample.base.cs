//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by StorageClassGenerator
//
//     Do not change code in this file, it will get lost when the file gets 
//     auto generated again. Write your code into Sample.cs.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
using System;
using System.Collections.Generic;
using System.Threading;
using StorageLib;


namespace TestContext  {


    /// <summary>
    /// Some comment for Sample
    /// </summary>
  public partial class Sample: IStorageItem<Sample> {

    #region Properties
    //      ----------

    /// <summary>
    /// Unique identifier for Sample. Gets set once Sample gets added to DC.Data.
    /// </summary>
    public int Key { get; private set; }
    internal static void SetKey(IStorageItem sample, int key, bool isRollback) {
#if DEBUG
      if (isRollback) {
        if (key==StorageExtensions.NoKey) {
          DC.Trace?.Invoke($"Release Sample key @{sample.Key} #{sample.GetHashCode()}");
        } else {
          DC.Trace?.Invoke($"Store Sample key @{key} #{sample.GetHashCode()}");
        }
      }
#endif
      ((Sample)sample).Key = key;
    }


    /// <summary>
    /// Some Text comment
    /// </summary>
    public string Text { get; private set; }


    /// <summary>
    /// Some Flag comment
    /// </summary>
    public bool Flag { get; private set; }


    /// <summary>
    /// Some Amount comment
    /// </summary>
    public int Number { get; private set; }


    /// <summary>
    /// Amount with 2 digits after comma comment
    /// Stores decimal with 2 digits after comma.
    /// </summary>
    public decimal Amount { get; private set; }


    /// <summary>
    /// Amount with 4 digits after comma comment
    /// Stores decimal with 4 digits after comma.
    /// </summary>
    public decimal Amount4 { get; private set; }


    /// <summary>
    /// Nullable amount with 5 digits after comma comment
    /// Stores decimal with 5 digits after comma.
    /// </summary>
    public decimal? Amount5 { get; private set; }


    /// <summary>
    /// PreciseDecimal with about 20 digits precision, takes more storage space then the other Decimalx types.
    /// Stores date and time with maximum precision.
    /// </summary>
    public decimal PreciseDecimal { get; private set; }


    /// <summary>
    /// Some SampleState comment
    /// </summary>
    public SampleStateEnum SampleState { get; private set; }


    /// <summary>
    /// Stores dates but not times
    /// Stores only dates but no times.
    /// </summary>
    public DateTime DateOnly { get; private set; }


    /// <summary>
    /// Stores times (24 hour timespan) but not date.
    /// Stores less than 24 hours with second precision.
    /// </summary>
    public TimeSpan TimeOnly { get; private set; }


    /// <summary>
    /// Stores date and time precisely to a tick.
    /// Stores date and time with tick precision.
    /// </summary>
    public DateTime DateTimeTicks { get; private set; }


    /// <summary>
    /// Stores date and time precisely to a minute.
    /// Stores date and time with minute preclusion.
    /// </summary>
    public DateTime DateTimeMinute { get; private set; }


    /// <summary>
    /// Stores date and time precisely to a second.
    /// Stores date and time with seconds precision.
    /// </summary>
    public DateTime DateTimeSecond { get; private set; }


    /// <summary>
    /// Some OneMaster comment
    /// </summary>
    public SampleMaster? OneMaster { get; private set; }


    /// <summary>
    /// Some OtherMaster comment
    /// </summary>
    public SampleMaster? OtherMaster { get; private set; }


    /// <summary>
    /// Some Optional comment
    /// </summary>
    public string? Optional { get; private set; }


    /// <summary>
    /// Some SampleDetails comment
    /// </summary>
    public IStorageReadOnlyList<SampleDetail> SampleDetails => sampleDetails;
    readonly StorageList<SampleDetail> sampleDetails;


    /// <summary>
    /// Headers written to first line in CSV file
    /// </summary>
    internal static readonly string[] Headers = {
      "Key", 
      "Text", 
      "Flag", 
      "Number", 
      "Amount", 
      "Amount4", 
      "Amount5", 
      "PreciseDecimal", 
      "SampleState", 
      "DateOnly", 
      "TimeOnly", 
      "DateTimeTicks", 
      "DateTimeMinute", 
      "DateTimeSecond", 
      "OneMaster", 
      "OtherMaster", 
      "Optional"
    };


    /// <summary>
    /// None existing Sample, used as a temporary place holder when reading a CSV file
    /// which was not compacted. It might create first a later deleted item linking to a 
    /// deleted parent. In this case, the parent property gets set to NoSample. Once the CSV
    /// file is completely read, that child will actually be deleted (released) and Verify()
    /// ensures that there are no stored children with links to NoSample.
    /// </summary>
    internal static Sample NoSample = new Sample("NoText", false, int.MinValue, Decimal.MinValue, Decimal.MinValue, null, Decimal.MinValue, 0, DateTime.MinValue.Date, TimeSpan.MinValue, DateTime.MinValue, DateTime.MinValue, DateTime.MinValue, null, null, null, isStoring: false);
    #endregion


    #region Events
    //      ------

    /// <summary>
    /// Content of Sample has changed. Gets only raised for changes occurring after loading DC.Data with previously stored data.
    /// </summary>
    public event Action</*old*/Sample, /*new*/Sample>? HasChanged;
    #endregion


    #region Constructors
    //      ------------

    /// <summary>
    /// Sample Constructor. If isStoring is true, adds Sample to DC.Data.SampleX.
    /// </summary>
    public Sample(
      string text, 
      bool flag, 
      int number, 
      decimal amount, 
      decimal amount4, 
      decimal? amount5, 
      decimal preciseDecimal, 
      SampleStateEnum sampleState, 
      DateTime dateOnly, 
      TimeSpan timeOnly, 
      DateTime dateTimeTicks, 
      DateTime dateTimeMinute, 
      DateTime dateTimeSecond, 
      SampleMaster? oneMaster, 
      SampleMaster? otherMaster, 
      string? optional, 
      bool isStoring = true)
    {
      Key = StorageExtensions.NoKey;
      Text = text;
      Flag = flag;
      Number = number;
      Amount = amount.Round(2);
      Amount4 = amount4.Round(4);
      Amount5 = amount5.Round(5);
      PreciseDecimal = preciseDecimal;
      SampleState = sampleState;
      DateOnly = dateOnly.Floor(Rounding.Days);
      TimeOnly = timeOnly.Round(Rounding.Seconds);
      DateTimeTicks = dateTimeTicks;
      DateTimeMinute = dateTimeMinute.Round(Rounding.Minutes);
      DateTimeSecond = dateTimeSecond.Round(Rounding.Seconds);
      OneMaster = oneMaster;
      OtherMaster = otherMaster;
      Optional = optional;
      sampleDetails = new StorageList<SampleDetail>();
#if DEBUG
      DC.Trace?.Invoke($"new Sample: {ToTraceString()}");
#endif
      if (OneMaster!=null) {
        OneMaster.AddToSampleX(this);
      }
      if (OtherMaster!=null) {
        OtherMaster.AddToSampleX(this);
      }
      onConstruct();
      if (DC.Data.IsTransaction) {
        DC.Data.AddTransaction(new TransactionItem(29,TransactionActivityEnum.New, Key, this));
      }

      if (isStoring) {
        Store();
      }
    }
    partial void onConstruct();


    /// <summary>
    /// Cloning constructor. It will copy all data from original except any collection (children).
    /// </summary>
    #pragma warning disable CS8618 // Children collections are uninitialized.
    public Sample(Sample original) {
    #pragma warning restore CS8618 //
      Key = StorageExtensions.NoKey;
      Text = original.Text;
      Flag = original.Flag;
      Number = original.Number;
      Amount = original.Amount;
      Amount4 = original.Amount4;
      Amount5 = original.Amount5;
      PreciseDecimal = original.PreciseDecimal;
      SampleState = original.SampleState;
      DateOnly = original.DateOnly;
      TimeOnly = original.TimeOnly;
      DateTimeTicks = original.DateTimeTicks;
      DateTimeMinute = original.DateTimeMinute;
      DateTimeSecond = original.DateTimeSecond;
      OneMaster = original.OneMaster;
      OtherMaster = original.OtherMaster;
      Optional = original.Optional;
      onCloned(this);
    }
    partial void onCloned(Sample clone);


    /// <summary>
    /// Constructor for Sample read from CSV file
    /// </summary>
    private Sample(int key, CsvReader csvReader){
      Key = key;
      Text = csvReader.ReadString();
      Flag = csvReader.ReadBool();
      Number = csvReader.ReadInt();
      Amount = csvReader.ReadDecimal();
      Amount4 = csvReader.ReadDecimal();
      Amount5 = csvReader.ReadDecimalNull();
      PreciseDecimal = csvReader.ReadDecimal();
      SampleState = (SampleStateEnum)csvReader.ReadInt();
      DateOnly = csvReader.ReadDate();
      TimeOnly = csvReader.ReadTime();
      DateTimeTicks = csvReader.ReadDateTimeTicks();
      DateTimeMinute = csvReader.ReadDateSeconds();
      DateTimeSecond = csvReader.ReadDateSeconds();
      var oneMasterKey = csvReader.ReadIntNull();
      if (oneMasterKey.HasValue) {
        OneMaster = DC.Data._SampleMasters.GetItem(oneMasterKey.Value)?? SampleMaster.NoSampleMaster;
      }
      var otherMasterKey = csvReader.ReadIntNull();
      if (otherMasterKey.HasValue) {
        OtherMaster = DC.Data._SampleMasters.GetItem(otherMasterKey.Value)?? SampleMaster.NoSampleMaster;
      }
      Optional = csvReader.ReadStringNull();
      sampleDetails = new StorageList<SampleDetail>();
      if (oneMasterKey.HasValue && OneMaster!=SampleMaster.NoSampleMaster) {
        OneMaster!.AddToSampleX(this);
      }
      if (otherMasterKey.HasValue && OtherMaster!=SampleMaster.NoSampleMaster) {
        OtherMaster!.AddToSampleX(this);
      }
      onCsvConstruct();
    }
    partial void onCsvConstruct();


    /// <summary>
    /// New Sample read from CSV file
    /// </summary>
    internal static Sample Create(int key, CsvReader csvReader) {
      return new Sample(key, csvReader);
    }


    /// <summary>
    /// Verify that sample.OneMaster exists.
    /// Verify that sample.OtherMaster exists.
    /// </summary>
    internal static bool Verify(Sample sample) {
      if (sample.OneMaster==SampleMaster.NoSampleMaster) return false;
      if (sample.OtherMaster==SampleMaster.NoSampleMaster) return false;
      return true;
    }
    #endregion


    #region Methods
    //      -------

    /// <summary>
    /// Adds Sample to DC.Data.SampleX.<br/>
    /// Throws an Exception when Sample is already stored.
    /// </summary>
    public void Store() {
      if (Key>=0) {
        throw new Exception($"Sample cannot be stored again in DC.Data, key {Key} is greater equal 0." + Environment.NewLine + ToString());
      }

      var isCancelled = false;
      onStoring(ref isCancelled);
      if (isCancelled) return;

      if (OneMaster?.Key<0) {
        throw new Exception($"Cannot store child Sample '{this}'.OneMaster to SampleMaster '{OneMaster}' because parent is not stored yet.");
      }
      if (OtherMaster?.Key<0) {
        throw new Exception($"Cannot store child Sample '{this}'.OtherMaster to SampleMaster '{OtherMaster}' because parent is not stored yet.");
      }
      DC.Data._SampleX.Add(this);
      onStored();
#if DEBUG
      DC.Trace?.Invoke($"Stored Sample #{GetHashCode()} @{Key}");
#endif
    }
    partial void onStoring(ref bool isCancelled);
    partial void onStored();


    /// <summary>
    /// Estimated number of UTF8 characters needed to write Sample to CSV file
    /// </summary>
    public const int EstimatedLineLength = 457;


    /// <summary>
    /// Write Sample to CSV file
    /// </summary>
    internal static void Write(Sample sample, CsvWriter csvWriter) {
      sample.onCsvWrite();
      csvWriter.Write(sample.Text);
      csvWriter.Write(sample.Flag);
      csvWriter.Write(sample.Number);
      csvWriter.WriteDecimal2(sample.Amount);
      csvWriter.WriteDecimal4(sample.Amount4);
      csvWriter.WriteDecimal5(sample.Amount5);
      csvWriter.Write(sample.PreciseDecimal);
      csvWriter.Write((int)sample.SampleState);
      csvWriter.WriteDate(sample.DateOnly);
      csvWriter.WriteTime(sample.TimeOnly);
      csvWriter.WriteDateTimeTicks(sample.DateTimeTicks);
      csvWriter.WriteDateMinutes(sample.DateTimeMinute);
      csvWriter.WriteDateSeconds(sample.DateTimeSecond);
      if (sample.OneMaster is null) {
        csvWriter.WriteNull();
      } else {
        if (sample.OneMaster.Key<0) throw new Exception($"Cannot write sample '{sample}' to CSV File, because OneMaster is not stored in DC.Data.SampleMasters.");

        csvWriter.Write(sample.OneMaster.Key.ToString());
      }
      if (sample.OtherMaster is null) {
        csvWriter.WriteNull();
      } else {
        if (sample.OtherMaster.Key<0) throw new Exception($"Cannot write sample '{sample}' to CSV File, because OtherMaster is not stored in DC.Data.SampleMasters.");

        csvWriter.Write(sample.OtherMaster.Key.ToString());
      }
      csvWriter.Write(sample.Optional);
    }
    partial void onCsvWrite();


    /// <summary>
    /// Updates Sample with the provided values
    /// </summary>
    public void Update(
      string text, 
      bool flag, 
      int number, 
      decimal amount, 
      decimal amount4, 
      decimal? amount5, 
      decimal preciseDecimal, 
      SampleStateEnum sampleState, 
      DateTime dateOnly, 
      TimeSpan timeOnly, 
      DateTime dateTimeTicks, 
      DateTime dateTimeMinute, 
      DateTime dateTimeSecond, 
      SampleMaster? oneMaster, 
      SampleMaster? otherMaster, 
      string? optional)
    {
      if (Key>=0){
        if (oneMaster?.Key<0) {
          throw new Exception($"Sample.Update(): It is illegal to add stored Sample '{this}'" + Environment.NewLine + 
            $"to OneMaster '{oneMaster}', which is not stored.");
        }
        if (otherMaster?.Key<0) {
          throw new Exception($"Sample.Update(): It is illegal to add stored Sample '{this}'" + Environment.NewLine + 
            $"to OtherMaster '{otherMaster}', which is not stored.");
        }
      }
      var clone = new Sample(this);
      var isCancelled = false;
      onUpdating(
        text, 
        flag, 
        number, 
        amount, 
        amount4, 
        amount5, 
        preciseDecimal, 
        sampleState, 
        dateOnly, 
        timeOnly, 
        dateTimeTicks, 
        dateTimeMinute, 
        dateTimeSecond, 
        oneMaster, 
        otherMaster, 
        optional, 
        ref isCancelled);
      if (isCancelled) return;

#if DEBUG
      DC.Trace?.Invoke($"Updating Sample: {ToTraceString()}");
#endif

      //remove not yet updated item from parents which will be removed by update
      var hasOneMasterChanged = OneMaster!=oneMaster;
      if (OneMaster is not null && hasOneMasterChanged) {
        OneMaster.RemoveFromSampleX(this);
      }
      var hasOtherMasterChanged = OtherMaster!=otherMaster;
      if (OtherMaster is not null && hasOtherMasterChanged) {
        OtherMaster.RemoveFromSampleX(this);
      }

      //update properties and detect if any value has changed
      var isChangeDetected = false;
      if (Text!=text) {
        Text = text;
        isChangeDetected = true;
      }
      if (Flag!=flag) {
        Flag = flag;
        isChangeDetected = true;
      }
      if (Number!=number) {
        Number = number;
        isChangeDetected = true;
      }
      var amountRounded = amount.Round(2);
      if (Amount!=amountRounded) {
        Amount = amountRounded;
        isChangeDetected = true;
      }
      var amount4Rounded = amount4.Round(4);
      if (Amount4!=amount4Rounded) {
        Amount4 = amount4Rounded;
        isChangeDetected = true;
      }
      var amount5Rounded = amount5.Round(5);
      if (Amount5!=amount5Rounded) {
        Amount5 = amount5Rounded;
        isChangeDetected = true;
      }
      if (PreciseDecimal!=preciseDecimal) {
        PreciseDecimal = preciseDecimal;
        isChangeDetected = true;
      }
      if (SampleState!=sampleState) {
        SampleState = sampleState;
        isChangeDetected = true;
      }
      var dateOnlyRounded = dateOnly.Floor(Rounding.Days);
      if (DateOnly!=dateOnlyRounded) {
        DateOnly = dateOnlyRounded;
        isChangeDetected = true;
      }
      var timeOnlyRounded = timeOnly.Round(Rounding.Seconds);
      if (TimeOnly!=timeOnlyRounded) {
        TimeOnly = timeOnlyRounded;
        isChangeDetected = true;
      }
      if (DateTimeTicks!=dateTimeTicks) {
        DateTimeTicks = dateTimeTicks;
        isChangeDetected = true;
      }
      var dateTimeMinuteRounded = dateTimeMinute.Round(Rounding.Minutes);
      if (DateTimeMinute!=dateTimeMinuteRounded) {
        DateTimeMinute = dateTimeMinuteRounded;
        isChangeDetected = true;
      }
      var dateTimeSecondRounded = dateTimeSecond.Round(Rounding.Seconds);
      if (DateTimeSecond!=dateTimeSecondRounded) {
        DateTimeSecond = dateTimeSecondRounded;
        isChangeDetected = true;
      }
      if (OneMaster!=oneMaster) {
        OneMaster = oneMaster;
        isChangeDetected = true;
      }
      if (OtherMaster!=otherMaster) {
        OtherMaster = otherMaster;
        isChangeDetected = true;
      }
      if (Optional!=optional) {
        Optional = optional;
        isChangeDetected = true;
      }

      //add updated item to parents which have been newly added during update
      if (OneMaster is not null && hasOneMasterChanged) {
        OneMaster.AddToSampleX(this);
      }
      if (OtherMaster is not null && hasOtherMasterChanged) {
        OtherMaster.AddToSampleX(this);
      }
      if (isChangeDetected) {
        onUpdated(clone);
        if (Key>=0) {
          DC.Data._SampleX.ItemHasChanged(clone, this);
        } else if (DC.Data.IsTransaction) {
          DC.Data.AddTransaction(new TransactionItem(29, TransactionActivityEnum.Update, Key, this, oldItem: clone));
        }
        HasChanged?.Invoke(clone, this);
      }
#if DEBUG
      DC.Trace?.Invoke($"Updated Sample: {ToTraceString()}");
#endif
    }
    partial void onUpdating(
      string text, 
      bool flag, 
      int number, 
      decimal amount, 
      decimal amount4, 
      decimal? amount5, 
      decimal preciseDecimal, 
      SampleStateEnum sampleState, 
      DateTime dateOnly, 
      TimeSpan timeOnly, 
      DateTime dateTimeTicks, 
      DateTime dateTimeMinute, 
      DateTime dateTimeSecond, 
      SampleMaster? oneMaster, 
      SampleMaster? otherMaster, 
      string? optional, 
      ref bool isCancelled);
    partial void onUpdated(Sample old);


    /// <summary>
    /// Updates this Sample with values from CSV file
    /// </summary>
    internal static void Update(Sample sample, CsvReader csvReader){
      sample.Text = csvReader.ReadString();
      sample.Flag = csvReader.ReadBool();
      sample.Number = csvReader.ReadInt();
      sample.Amount = csvReader.ReadDecimal();
      sample.Amount4 = csvReader.ReadDecimal();
      sample.Amount5 = csvReader.ReadDecimalNull();
      sample.PreciseDecimal = csvReader.ReadDecimal();
      sample.SampleState = (SampleStateEnum)csvReader.ReadInt();
      sample.DateOnly = csvReader.ReadDate();
      sample.TimeOnly = csvReader.ReadTime();
      sample.DateTimeTicks = csvReader.ReadDateTimeTicks();
      sample.DateTimeMinute = csvReader.ReadDateSeconds();
      sample.DateTimeSecond = csvReader.ReadDateSeconds();
      var oneMasterKey = csvReader.ReadIntNull();
      SampleMaster? oneMaster;
      if (oneMasterKey is null) {
        oneMaster = null;
      } else {
        oneMaster = DC.Data._SampleMasters.GetItem(oneMasterKey.Value)??
          SampleMaster.NoSampleMaster;
      }
      if (sample.OneMaster is null) {
        if (oneMaster is null) {
          //nothing to do
        } else {
          sample.OneMaster = oneMaster;
          sample.OneMaster.AddToSampleX(sample);
        }
      } else {
        if (oneMaster is null) {
          if (sample.OneMaster!=SampleMaster.NoSampleMaster) {
            sample.OneMaster.RemoveFromSampleX(sample);
          }
          sample.OneMaster = null;
        } else {
          if (sample.OneMaster!=SampleMaster.NoSampleMaster) {
            sample.OneMaster.RemoveFromSampleX(sample);
          }
          sample.OneMaster = oneMaster;
          sample.OneMaster.AddToSampleX(sample);
        }
      }
      var otherMasterKey = csvReader.ReadIntNull();
      SampleMaster? otherMaster;
      if (otherMasterKey is null) {
        otherMaster = null;
      } else {
        otherMaster = DC.Data._SampleMasters.GetItem(otherMasterKey.Value)??
          SampleMaster.NoSampleMaster;
      }
      if (sample.OtherMaster is null) {
        if (otherMaster is null) {
          //nothing to do
        } else {
          sample.OtherMaster = otherMaster;
          sample.OtherMaster.AddToSampleX(sample);
        }
      } else {
        if (otherMaster is null) {
          if (sample.OtherMaster!=SampleMaster.NoSampleMaster) {
            sample.OtherMaster.RemoveFromSampleX(sample);
          }
          sample.OtherMaster = null;
        } else {
          if (sample.OtherMaster!=SampleMaster.NoSampleMaster) {
            sample.OtherMaster.RemoveFromSampleX(sample);
          }
          sample.OtherMaster = otherMaster;
          sample.OtherMaster.AddToSampleX(sample);
        }
      }
      sample.Optional = csvReader.ReadStringNull();
      sample.onCsvUpdate();
    }
    partial void onCsvUpdate();


    /// <summary>
    /// Add sampleDetail to SampleDetails.
    /// </summary>
    internal void AddToSampleDetails(SampleDetail sampleDetail) {
#if DEBUG
      if (sampleDetail==SampleDetail.NoSampleDetail) throw new Exception();
      if ((sampleDetail.Key>=0)&&(Key<0)) throw new Exception();
      if (sampleDetails.Contains(sampleDetail)) throw new Exception();
#endif
      sampleDetails.Add(sampleDetail);
      onAddedToSampleDetails(sampleDetail);
#if DEBUG
      DC.Trace?.Invoke($"Add SampleDetail {sampleDetail.GetKeyOrHash()} to " +
        $"{this.GetKeyOrHash()} Sample.SampleDetails");
#endif
    }
    partial void onAddedToSampleDetails(SampleDetail sampleDetail);


    /// <summary>
    /// Removes sampleDetail from Sample.
    /// </summary>
    internal void RemoveFromSampleDetails(SampleDetail sampleDetail) {
#if DEBUG
      if (!sampleDetails.Remove(sampleDetail)) throw new Exception();
#else
        sampleDetails.Remove(sampleDetail);
#endif
      onRemovedFromSampleDetails(sampleDetail);
#if DEBUG
      DC.Trace?.Invoke($"Remove SampleDetail {sampleDetail.GetKeyOrHash()} from " +
        $"{this.GetKeyOrHash()} Sample.SampleDetails");
#endif
    }
    partial void onRemovedFromSampleDetails(SampleDetail sampleDetail);


    /// <summary>
    /// Removes Sample from DC.Data.SampleX.
    /// </summary>
    public void Release() {
      if (Key<0) {
        throw new Exception($"Sample.Release(): Sample '{this}' is not stored in DC.Data, key is {Key}.");
      }
      foreach (var sampleDetail in SampleDetails) {
        if (sampleDetail?.Key>=0) {
          throw new Exception($"Cannot release Sample '{this}' " + Environment.NewLine + 
            $"because '{sampleDetail}' in Sample.SampleDetails is still stored.");
        }
      }
      onReleasing();
      DC.Data._SampleX.Remove(Key);
      onReleased();
#if DEBUG
      DC.Trace?.Invoke($"Released Sample @{Key} #{GetHashCode()}");
#endif
    }
    partial void onReleasing();
    partial void onReleased();


    /// <summary>
    /// Removes Sample from parents as part of a transaction rollback of the new() statement.
    /// </summary>
    internal static void RollbackItemNew(IStorageItem item) {
      var sample = (Sample) item;
#if DEBUG
      DC.Trace?.Invoke($"Rollback new Sample(): {sample.ToTraceString()}");
#endif
      if (sample.OneMaster!=null && sample.OneMaster!=SampleMaster.NoSampleMaster) {
        sample.OneMaster.RemoveFromSampleX(sample);
      }
      if (sample.OtherMaster!=null && sample.OtherMaster!=SampleMaster.NoSampleMaster) {
        sample.OtherMaster.RemoveFromSampleX(sample);
      }
      sample.onRollbackItemNew();
    }
    partial void onRollbackItemNew();


    /// <summary>
    /// Releases Sample from DC.Data.SampleX as part of a transaction rollback of Store().
    /// </summary>
    internal static void RollbackItemStore(IStorageItem item) {
      var sample = (Sample) item;
#if DEBUG
      DC.Trace?.Invoke($"Rollback Sample.Store(): {sample.ToTraceString()}");
#endif
      sample.onRollbackItemStored();
    }
    partial void onRollbackItemStored();


    /// <summary>
    /// Restores the Sample item data as it was before the last update as part of a transaction rollback.
    /// </summary>
    internal static void RollbackItemUpdate(IStorageItem oldStorageItem, IStorageItem newStorageItem) {
      var oldItem = (Sample) oldStorageItem;//an item clone with the values before item was updated
      var item = (Sample) newStorageItem;//is the instance whose values should be restored
#if DEBUG
      DC.Trace?.Invoke($"Rolling back Sample.Update(): {item.ToTraceString()}");
#endif

      // remove updated item from parents
      var hasOneMasterChanged = oldItem.OneMaster!=item.OneMaster;
      if (hasOneMasterChanged && item.OneMaster is not null) {
        item.OneMaster.RemoveFromSampleX(item);
      }
      var hasOtherMasterChanged = oldItem.OtherMaster!=item.OtherMaster;
      if (hasOtherMasterChanged && item.OtherMaster is not null) {
        item.OtherMaster.RemoveFromSampleX(item);
      }

      // updated item: restore old values
      item.Text = oldItem.Text;
      item.Flag = oldItem.Flag;
      item.Number = oldItem.Number;
      item.Amount = oldItem.Amount;
      item.Amount4 = oldItem.Amount4;
      item.Amount5 = oldItem.Amount5;
      item.PreciseDecimal = oldItem.PreciseDecimal;
      item.SampleState = oldItem.SampleState;
      item.DateOnly = oldItem.DateOnly;
      item.TimeOnly = oldItem.TimeOnly;
      item.DateTimeTicks = oldItem.DateTimeTicks;
      item.DateTimeMinute = oldItem.DateTimeMinute;
      item.DateTimeSecond = oldItem.DateTimeSecond;
      item.OneMaster = oldItem.OneMaster;
      item.OtherMaster = oldItem.OtherMaster;
      item.Optional = oldItem.Optional;

      // add item with previous values to parents
      if (hasOneMasterChanged && item.OneMaster is not null) {
        item.OneMaster.AddToSampleX(item);
      }
      if (hasOtherMasterChanged && item.OtherMaster is not null) {
        item.OtherMaster.AddToSampleX(item);
      }
      item.onRollbackItemUpdated(oldItem);
#if DEBUG
      DC.Trace?.Invoke($"Rolled back Sample.Update(): {item.ToTraceString()}");
#endif
    }
    partial void onRollbackItemUpdated(Sample oldSample);


    /// <summary>
    /// Adds Sample to DC.Data.SampleX as part of a transaction rollback of Release().
    /// </summary>
    internal static void RollbackItemRelease(IStorageItem item) {
      var sample = (Sample) item;
#if DEBUG
      DC.Trace?.Invoke($"Rollback Sample.Release(): {sample.ToTraceString()}");
#endif
      sample.onRollbackItemRelease();
    }
    partial void onRollbackItemRelease();


    /// <summary>
    /// Returns property values for tracing. Parents are shown with their key instead their content.
    /// </summary>
    public string ToTraceString() {
      var returnString =
        $"{this.GetKeyOrHash()}|" +
        $" {Text}|" +
        $" {Flag}|" +
        $" {Number}|" +
        $" {Amount}|" +
        $" {Amount4}|" +
        $" {Amount5}|" +
        $" {PreciseDecimal}|" +
        $" {SampleState}|" +
        $" {DateOnly.ToShortDateString()}|" +
        $" {TimeOnly}|" +
        $" {DateTimeTicks}|" +
        $" {DateTimeMinute}|" +
        $" {DateTimeSecond}|" +
        $" OneMaster {OneMaster?.GetKeyOrHash()}|" +
        $" OtherMaster {OtherMaster?.GetKeyOrHash()}|" +
        $" {Optional}";
      onToTraceString(ref returnString);
      return returnString;
    }
    partial void onToTraceString(ref string returnString);


    /// <summary>
    /// Returns property values
    /// </summary>
    public string ToShortString() {
      var returnString =
        $"{Key.ToKeyString()}," +
        $" {Text}," +
        $" {Flag}," +
        $" {Number}," +
        $" {Amount}," +
        $" {Amount4}," +
        $" {Amount5}," +
        $" {PreciseDecimal}," +
        $" {SampleState}," +
        $" {DateOnly.ToShortDateString()}," +
        $" {TimeOnly}," +
        $" {DateTimeTicks}," +
        $" {DateTimeMinute}," +
        $" {DateTimeSecond}," +
        $" {OneMaster?.ToShortString()}," +
        $" {OtherMaster?.ToShortString()}," +
        $" {Optional}";
      onToShortString(ref returnString);
      return returnString;
    }
    partial void onToShortString(ref string returnString);


    /// <summary>
    /// Returns all property names and values
    /// </summary>
    public override string ToString() {
      var returnString =
        $"Key: {Key.ToKeyString()}," +
        $" Text: {Text}," +
        $" Flag: {Flag}," +
        $" Number: {Number}," +
        $" Amount: {Amount}," +
        $" Amount4: {Amount4}," +
        $" Amount5: {Amount5}," +
        $" PreciseDecimal: {PreciseDecimal}," +
        $" SampleState: {SampleState}," +
        $" DateOnly: {DateOnly.ToShortDateString()}," +
        $" TimeOnly: {TimeOnly}," +
        $" DateTimeTicks: {DateTimeTicks}," +
        $" DateTimeMinute: {DateTimeMinute}," +
        $" DateTimeSecond: {DateTimeSecond}," +
        $" OneMaster: {OneMaster?.ToShortString()}," +
        $" OtherMaster: {OtherMaster?.ToShortString()}," +
        $" Optional: {Optional}," +
        $" SampleDetails: {SampleDetails.Count}," +
        $" SampleDetailsStored: {SampleDetails.CountStoredItems};";
      onToString(ref returnString);
      return returnString;
    }
    partial void onToString(ref string returnString);
    #endregion
  }
}
