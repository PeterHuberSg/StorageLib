//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by StorageClassGenerator
//
//     Do not change code in this file, it will get lost when the file gets 
//     auto generated again. Write your code into DC.cs.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
using System;
using System.Threading;
using StorageLib;


namespace YourNameSpace  {

  /// <summary>
  /// A part of DC is static, which gives easy access to all stored data (=context) through DC.Data. But most functionality is in the
  /// instantiatable part of DC. Since it is instantiatable, is possible to use different contexts over the lifetime of a program. This 
  /// is helpful for unit testing. Use DC.Init() to create a new context and dispose it with DisposeData() before creating a new one.
  /// </summary>
  public partial class DC: DataContextBase {

    #region static Part
    //      -----------

    /// <summary>
    /// Provides static root access to the data context
    /// </summary>
    public static DC Data {
      get { return data!; }
    }
    private static DC? data; //data is needed for Interlocked.Exchange(ref data, null) in DisposeData()


    /// <summary>
    /// Flushes all data to permanent storage location if permanent data storage is active. Compacts data storage
    /// by applying all updates and removing all instances marked as deleted.
    /// </summary>
    public static void DisposeData() {
      var dataLocal = Interlocked.Exchange(ref data, null);
      dataLocal?.Dispose();
    }
    #endregion


    #region Properties
    //      ----------

    /// <summary>
    /// Configuration parameters if data gets stored in .csv files
    /// </summary>
    public CsvConfig? CsvConfig { get; }

    /// <summary>
    /// Is all data initialised
    /// </summary>
    public bool IsInitialised { get; private set; }

    /// <summary>
    /// Directory of all Children
    /// </summary>
    public IReadonlyDataStore<Child> Children => _Children;
    internal DataStore<Child> _Children { get; private set; }

    /// <summary>
    /// Directory of all Parents
    /// </summary>
    public IReadonlyDataStore<Parent> Parents => _Parents;
    internal DataStore<Parent> _Parents { get; private set; }
    #endregion


    #region Events
    //      ------

    #endregion


    #region Constructors
    //      ------------

    /// <summary>
    /// Creates a new DataContext. If csvConfig is null, the data is only stored in RAM and gets lost once the 
    /// program terminates. With csvConfig defined, existing data gets read at startup, changes get immediately
    /// written and Dispose() ensures by flushing that all data is permanently stored.
    /// </summary>
    public DC(CsvConfig? csvConfig): base(DataStoresCount: 2) {
      data = this;
      IsInitialised = false;

      string? backupResult = null;
      if (csvConfig!=null) {
        backupResult = Csv.Backup(csvConfig, DateTime.Now);
      }

      CsvConfig = csvConfig;
      onConstructing(backupResult);

      if (csvConfig==null) {
        _Parents = new DataStore<Parent>(
          this,
          0,
          Parent.SetKey,
          Parent.RollbackItemNew,
          Parent.RollbackItemStore,
          null,
          null,
          areInstancesUpdatable: false,
          areInstancesReleasable: false);
        DataStores[0] = _Parents;
        onParentsFilled();

        _Children = new DataStore<Child>(
          this,
          1,
          Child.SetKey,
          Child.RollbackItemNew,
          Child.RollbackItemStore,
          Child.RollbackItemUpdate,
          Child.RollbackItemRelease,
          areInstancesUpdatable: true,
          areInstancesReleasable: true);
        DataStores[1] = _Children;
        onChildrenFilled();

      } else {
        _Parents = new DataStoreCSV<Parent>(
          this,
          0,
          csvConfig!,
          Parent.EstimatedLineLength,
          Parent.Headers,
          Parent.SetKey,
          Parent.Create,
          null,
          null,
          Parent.Write,
          Parent.RollbackItemNew,
          Parent.RollbackItemStore,
          null,
          null,
          areInstancesUpdatable: false,
          areInstancesReleasable: false);
        DataStores[0] = _Parents;
        onParentsFilled();

        _Children = new DataStoreCSV<Child>(
          this,
          1,
          csvConfig!,
          Child.EstimatedLineLength,
          Child.Headers,
          Child.SetKey,
          Child.Create,
          Child.Verify,
          Child.Update,
          Child.Write,
          Child.RollbackItemNew,
          Child.RollbackItemStore,
          Child.RollbackItemUpdate,
          Child.RollbackItemRelease,
          areInstancesUpdatable: true,
          areInstancesReleasable: true);
        DataStores[1] = _Children;
        onChildrenFilled();

      }
      onConstructed();
      IsInitialised = true;
    }

    /// <summary>}
    /// Called at beginning of constructor
    /// </summary>}
    partial void onConstructing(string? backupResult);

    /// <summary>}
    /// Called at end of constructor
    /// </summary>}
    partial void onConstructed();

    /// <summary>}
    /// Called once the data for Parents is read.
    /// </summary>}
    partial void onParentsFilled();

    /// <summary>}
    /// Called once the data for Children is read.
    /// </summary>}
    partial void onChildrenFilled();
    #endregion


    #region Overrides
    //      ---------

    internal new void AddTransaction(TransactionItem transactionItem) {
      base.AddTransaction(transactionItem);
    }


    protected override void Dispose(bool disposing) {
      if (disposing) {
        onDispose();
        _Children?.Dispose();
        _Children = null!;
        _Parents?.Dispose();
        _Parents = null!;
        data = null;
      }
      base.Dispose(disposing);
    }

    /// <summary>}
    /// Called before storageDirectories get disposed.
    /// </summary>}
    partial void onDispose();
    #endregion


    #region Methods
    //      -------

    #endregion

  }
}

